# Домашнє завдання №1: Сортування і структури даних

## Опис проєкту

База студентів зчитується з CSV-файлу `students.csv` і зберігається у пам’яті з використанням різних структур даних для оптимального виконання операцій.

---

## Структура даних `Student`

```cpp
struct Student {
    std::string m_name;         // ім'я українською
    std::string m_surname;      // прізвище українською
    std::string m_email;        // [a-z.]*@student.org
    int m_birth_year;           // 1950..2010
    int m_birth_month;          // 1..12
    int m_birth_day;            // 1..Number of days in month
    std::string m_group;        // [A-Z][A-Z][A-Z]-[0-9][0-9]
    float m_rating;             // 0..100
    std::string m_phone_number; // 38(0xx)xx-xx-xxx
};
```

### Варіанти операцій (Задача II)

У проєкті реалізовано варіант V4:

Повернути 100 студентів з найвищим рейтингом.

1) Знайти групу, в якій найбільше студентів
2) Змінити групу студенту за його електронною поштою (m_email)
3) Знайти групу, в якій найбільший середній рейтинг студентів.

Для виконання операцій використано три різні реалізації бази даних (StudentDB1, StudentDB2, StudentDB3) з різними комбінаціями контейнерів (хеш-таблиці, BST, вектор), щоб експериментально порівняти швидкість і використання пам’яті.

## Реалізації бази даних та використані структури даних

У проєкті реалізовано три варіанти бази даних студентів: `StudentDB1`, `StudentDB2` та `StudentDB3`.  
Кожен варіант використовує різні комбінації контейнерів для оптимізації швидкості виконання операцій та використання пам’яті.

---

### StudentDB1

- **Контейнери:**
    - `std::unordered_map<std::string, Student>` — для зберігання студентів по електронній пошті (`m_email`). Забезпечує **O(1)** доступ для операцій зміни групи.
    - `std::unordered_map<std::string, GroupData>` — для зберігання статистики груп (`count`, `total_rating`).
        - `count` — кількість студентів у групі
        - `total_rating` — сумарний рейтинг групи  
          Цей контейнер дозволяє **швидко знаходити групу з максимальною кількістю студентів або середнім рейтингом**.

- **Особливості:**
    - Операції `op1_max_student_group` та `op3_max_avg_rating_group` виконуються шляхом обходу карти `groups`.
    - Операція `op2_change_group_by_email` змінює групу студента та коригує статистику груп без повного обходу всіх студентів.
    - Підходить для великих баз з частими пошуками по email та обчисленням статистик груп.

---

### StudentDB2

- **Контейнери:**
    - Аналогічно до `StudentDB1`:
        - `std::map<std::string, Student>` для пошуку по email
        - `std::map<std::string, GroupData>` для статистики груп
---

### StudentDB3

- **Контейнери:**
    - `std::vector<Student>` — всі студенти зберігаються у векторі без додаткових карт.
        - Пошук виконується шляхом **послідовного перебору вектора**.
    - Для статистики груп (опція 1 та 3) тимчасово використовується:
        - `std::unordered_map<std::string, int>` — для підрахунку студентів у групі
        - `std::unordered_map<std::string, std::pair<double, int>>` — для обчислення середнього рейтингу

- **Особливості:**
    - Найпростіша реалізація — не використовує постійного кешування статистики.
    - Пошук і обчислення статистик потребує повного обходу всіх студентів, що робить операції **повільнішими при великих базах**.
    - Використання вектора дозволяє легко ітеруватися і сортувати дані стандартними алгоритмами.

---

### Порівняння структур
| Реалізація  | Основний контейнер        | Пошук по email | Пошук групи / рейтинг | Використання пам’яті | Швидкість |
|------------|--------------------------|----------------|---------------------|-------------------|-----------|
| `DB1`      | `unordered_map`          | O(1)           | O(number of groups) | середнє           | швидка    |
| `DB2`      | `map`                    | O(log n)       | O(number of groups) | середнє           | середня   |
| `DB3`      | `vector`                 | O(n)           | O(n)                | низька            | повільна при великих n |

- `DB1` оптимізована для **швидкого доступу по email і статистики груп** завдяки хеш-таблицям.
- `DB2` використовує **BST (`map`)**, що забезпечує логарифмічний доступ по email, трохи повільніший за DB1, але зберігає порядок елементів.
- `DB3` економить пам’ять, але операції масштабуються лінійно від розміру бази даних.

---

### Висновок

Вибір структури даних безпосередньо впливає на **швидкість виконання операцій** і **споживання пам’яті**:

- Для великих баз оптимальні `DB1` з `unordered_map` для швидкого доступу по email і підрахунку статистик груп.
- `DB2` використовує `map` (BST), що забезпечує логарифмічний доступ по email; трохи повільніше за DB1, але зберігає порядок елементів і також добре підходить для середніх обсягів даних.
- Для невеликих баз або коли важлива економія пам’яті, можна використовувати `DB3` на векторі.


### Варіанти сортування (Задача III)

Реалізовано дві реалізації сортування:

1) Стандартне сортування C++

```cpp
std::sort(students.begin(), students.end(), [](const Student& a, const Student& b){
    return a.m_rating > b.m_rating;
});

```

2) Власна реалізація сортування (Merge sort)

Сортування зберігає результати у CSV-файли:
```results/standard_sort.csv``` — стандартне сортування
```results/my_sort.csv``` — власна реалізація

- Для великих наборів даних `std::sort` зазвичай швидше, оскільки оптимізує випадки майже відсортованих даних та використовує InsertionSort для малих підмасивів.
- Merge Sort корисний, коли потрібна стабільність або контроль над конкретним алгоритмом сортування.


### Виконання експериментів

Для кожної реалізації бази даних проводились експерименти:
Розмір бази: 100, 1000, 10000, 100000 студентів
Час виконання: 10 секунд

Випадковий порядок операцій у співвідношенні 2:100:30, задане варіантом

Вимірювались:
Кількість виконаних операцій
Використання оперативної пам’яті (RAM)
Результати зберігаються у:

```results/result_ops.png```  — кількість операцій
```results/result_mem.png``` — використана пам’ять
```results/database_analitics.txt``` — зібрана разом інформація в txt форматі

А також ```sorting_analitics.txt``` — час сортування списку зі студентів.

### Інструкція запуску 

Скомпілювати:
```bash
mkdir build && cd build
cmake ..
make
```

Запустити програму:
```bash
./StudentDatabase
```

Результати експериментів будуть збережені у папці results/
